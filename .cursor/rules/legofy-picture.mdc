---
description: 
globs: 
alwaysApply: false
---
# Legofy: Python to JavaScript Conversion Guide

This guide explains how to convert the core functionality of the Python Legofy module to JavaScript. Legofy is a tool that transforms images into LEGO-style mosaics by replacing each pixel with a colored brick image.

## Original Python vs JavaScript Implementation

The original Python implementation uses PIL (Python Imaging Library) for image manipulation, while our JavaScript version uses the HTML5 Canvas API for similar functionality.

## Core Functions

### 1. Color Overlay Functions

These functions apply color transformations to make the brick templates match the source image pixels.

**Python:**
```python
def apply_color_overlay(image, color):
    '''Small function to apply an effect over an entire image'''
    overlay_red, overlay_green, overlay_blue = color
    channels = image.split()

    r = channels[0].point(lambda color: overlay_effect(color, overlay_red))
    g = channels[1].point(lambda color: overlay_effect(color, overlay_green))
    b = channels[2].point(lambda color: overlay_effect(color, overlay_blue))

    channels[0].paste(r)
    channels[1].paste(g)
    channels[2].paste(b)

    return Image.merge(image.mode, channels)

def overlay_effect(color, overlay):
    '''Actual overlay effect function'''
    if color < 33:
        return overlay - 100
    elif color > 233:
        return overlay + 100
    else:
        return overlay - 133 + color
```

**JavaScript:**
```javascript
function applyColorOverlay(imageData, color) {
  const [overlayRed, overlayGreen, overlayBlue] = color;
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
    data[i] = overlayEffect(data[i], overlayRed);       // Red
    data[i + 1] = overlayEffect(data[i + 1], overlayGreen); // Green
    data[i + 2] = overlayEffect(data[i + 2], overlayBlue);  // Blue
    // Alpha channel remains unchanged
  }
  
  return imageData;
}

function overlayEffect(color, overlay) {
  if (color < 33) {
    return overlay - 100;
  } else if (color > 233) {
    return overlay + 100;
  } else {
    return overlay - 133 + color;
  }
}
```

### 2. Make LEGO Image Function

This is the core function that creates the LEGO-style mosaic.

**Python:**
```python
def make_lego_image(thumbnail_image, brick_image):
    '''Create a lego version of an image from an image'''
    base_width, base_height = thumbnail_image.size
    brick_width, brick_height = brick_image.size

    rgb_image = thumbnail_image.convert('RGB')

    lego_image = Image.new("RGB", (base_width * brick_width,
                                   base_height * brick_height), "white")

    for brick_x in range(base_width):
        for brick_y in range(base_height):
            color = rgb_image.getpixel((brick_x, brick_y))
            lego_image.paste(apply_color_overlay(brick_image, color),
                             (brick_x * brick_width, brick_y * brick_height))
    return lego_image
```

**JavaScript:**
```javascript
function makeLegoImage(thumbnailImage, brickImage) {
  // Create canvas for working with image data
  const sourceCanvas = document.createElement('canvas');
  const sourceCtx = sourceCanvas.getContext('2d');
  sourceCanvas.width = thumbnailImage.width;
  sourceCanvas.height = thumbnailImage.height;
  sourceCtx.drawImage(thumbnailImage, 0, 0);
  
  // Get pixel data from source image
  const sourceData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
  
  // Create canvas for the LEGO version
  const legoCanvas = document.createElement('canvas');
  const legoCtx = legoCanvas.getContext('2d');
  legoCanvas.width = sourceCanvas.width * brickImage.width;
  legoCanvas.height = sourceCanvas.height * brickImage.height;
  legoCtx.fillStyle = 'white';
  legoCtx.fillRect(0, 0, legoCanvas.width, legoCanvas.height);
  
  // Create a temporary canvas for brick manipulation
  const brickCanvas = document.createElement('canvas');
  const brickCtx = brickCanvas.getContext('2d');
  brickCanvas.width = brickImage.width;
  brickCanvas.height = brickImage.height;
  
  // Process each pixel in the source image
  for (let brickX = 0; brickX < sourceCanvas.width; brickX++) {
    for (let brickY = 0; brickY < sourceCanvas.height; brickY++) {
      // Get pixel color from source image
      const pixelIndex = (brickY * sourceCanvas.width + brickX) * 4;
      const color = [
        sourceData.data[pixelIndex],
        sourceData.data[pixelIndex + 1],
        sourceData.data[pixelIndex + 2]
      ];
      
      // Reset brick canvas with original brick
      brickCtx.clearRect(0, 0, brickCanvas.width, brickCanvas.height);
      brickCtx.drawImage(brickImage, 0, 0);
      
      // Apply color overlay to brick
      const brickData = brickCtx.getImageData(0, 0, brickCanvas.width, brickCanvas.height);
      const coloredBrickData = applyColorOverlay(brickData, color);
      brickCtx.putImageData(coloredBrickData, 0, 0);
      
      // Place colored brick on LEGO canvas
      legoCtx.drawImage(
        brickCanvas, 
        brickX * brickImage.width, 
        brickY * brickImage.height
      );
    }
  }
  
  return legoCanvas;
}
```

### 3. Size Calculation Function

This function determines the appropriate size for the source image.

**Python:**
```python
def get_new_size(base_image, brick_image, size=None):
    '''Returns a new size the first image should be so that the second one fits neatly in the longest axis'''
    new_size = base_image.size
    if size:
        scale_x, scale_y = size, size
    else:
        scale_x, scale_y = brick_image.size

    if new_size[0] > scale_x or new_size[1] > scale_y:
        if new_size[0] < new_size[1]:
            scale = new_size[1] / scale_y
        else:
            scale = new_size[0] / scale_x

        new_size = (int(round(new_size[0] / scale)) or 1,
                    int(round(new_size[1] / scale)) or 1)

    return new_size
```

**JavaScript:**
```javascript
function getNewSize(baseImage, brickImage, size = null) {
  let newWidth = baseImage.width;
  let newHeight = baseImage.height;
  
  // Determine scale factors
  const scaleX = size || brickImage.width;
  const scaleY = size || brickImage.height;
  
  // Resize if image is larger than constraints
  if (newWidth > scaleX || newHeight > scaleY) {
    let scale;
    
    if (newWidth < newHeight) {
      scale = newHeight / scaleY;
    } else {
      scale = newWidth / scaleX;
    }
    
    newWidth = Math.max(Math.round(newWidth / scale), 1);
    newHeight = Math.max(Math.round(newHeight / scale), 1);
  }
  
  return { width: newWidth, height: newHeight };
}
```

## Usage Example

Here's how to use the JavaScript implementation:

```javascript
// Load the source image
const baseImage = new Image();
baseImage.onload = function() {
  // Load the brick template
  const brickImage = new Image();
  brickImage.onload = function() {
    // Create LEGO version
    const legoCanvas = legofyImage(baseImage, brickImage);
    
    // Add the result to the document
    document.body.appendChild(legoCanvas);
    
    // Or convert to data URL for saving
    const dataUrl = legoCanvas.toDataURL('image/png');
    
    // Create download link
    const link = document.createElement('a');
    link.download = 'legofy_image.png';
    link.href = dataUrl;
    link.click();
  };
  brickImage.src = 'path/to/brick.png';
};
baseImage.src = 'path/to/source-image.jpg';
```

## Key Differences Between Python and JavaScript Implementations

1. **Image Processing Libraries**:
   - Python uses PIL/Pillow for image manipulation
   - JavaScript uses HTML5 Canvas API

2. **Image Data Access**:
   - Python: Direct pixel access through `getpixel()` method
   - JavaScript: Pixel data accessed through `getImageData()` and manipulated via array

3. **Image Creation**:
   - Python: Creates new PIL Image objects
   - JavaScript: Creates and manipulates Canvas elements

4. **Asynchronous Loading**:
   - JavaScript requires handling image loading asynchronously with callbacks or promises

5. **Output Format**:
   - Python: Saves directly to file
   - JavaScript: Returns a Canvas that can be converted to data URL, Blob, or appended to the DOM

## Missing Features from Python Version

The JavaScript implementation focuses on the core functionality. The following features from the Python version are not included:

1. **LEGO Color Palette**: The `apply_thumbnail_effects` function that restricts colors to LEGO-specific palettes
2. **GIF Support**: Processing of animated GIFs
3. **Command-line Interface**: The Python version has CLI support

These features could be added in future iterations of the JavaScript version.

## Performance Considerations

The JavaScript implementation can be computationally intensive for large images, as it processes each pixel individually. Consider adding:

1. **Progress Indicators**: For large images
2. **Web Workers**: To move processing off the main thread
3. **Chunking**: Process the image in chunks to avoid blocking the UI

## Browser Compatibility

The implementation uses standard Canvas API features supported by all modern browsers. For older browsers, consider using polyfills or fallbacks.